// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_BODYDATA_BODYDATA_H_
#define FLATBUFFERS_GENERATED_BODYDATA_BODYDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace BodyData {

struct Point;

struct Body;
struct BodyT;

struct Bodies;
struct BodiesT;

MANUALLY_ALIGNED_STRUCT(8) Point FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;

 public:
  Point() { memset(this, 0, sizeof(Point)); }
  Point(const Point &_o) { memcpy(this, &_o, sizeof(Point)); }
  Point(double _x, double _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Point, 16);

struct BodyT : public flatbuffers::NativeTable {
  typedef Body TableType;
  std::string name;
  std::vector<Point> positions;
  std::vector<Point> momenta;
  std::string parent;
  BodyT() {}
};

struct Body FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BodyT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_POSITIONS = 6,
    VT_MOMENTA = 8,
    VT_PARENT = 10
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const flatbuffers::Vector<const Point *> *positions() const { return GetPointer<const flatbuffers::Vector<const Point *> *>(VT_POSITIONS); }
  const flatbuffers::Vector<const Point *> *momenta() const { return GetPointer<const flatbuffers::Vector<const Point *> *>(VT_MOMENTA); }
  const flatbuffers::String *parent() const { return GetPointer<const flatbuffers::String *>(VT_PARENT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITIONS) &&
           verifier.Verify(positions()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MOMENTA) &&
           verifier.Verify(momenta()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PARENT) &&
           verifier.Verify(parent()) &&
           verifier.EndTable();
  }
  BodyT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Body> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BodyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Body::VT_NAME, name); }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const Point *>> positions) { fbb_.AddOffset(Body::VT_POSITIONS, positions); }
  void add_momenta(flatbuffers::Offset<flatbuffers::Vector<const Point *>> momenta) { fbb_.AddOffset(Body::VT_MOMENTA, momenta); }
  void add_parent(flatbuffers::Offset<flatbuffers::String> parent) { fbb_.AddOffset(Body::VT_PARENT, parent); }
  BodyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BodyBuilder &operator=(const BodyBuilder &);
  flatbuffers::Offset<Body> Finish() {
    auto o = flatbuffers::Offset<Body>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Point *>> positions = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Point *>> momenta = 0,
    flatbuffers::Offset<flatbuffers::String> parent = 0) {
  BodyBuilder builder_(_fbb);
  builder_.add_parent(parent);
  builder_.add_momenta(momenta);
  builder_.add_positions(positions);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Body> CreateBodyDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<const Point *> *positions = nullptr,
    const std::vector<const Point *> *momenta = nullptr,
    const char *parent = nullptr) {
  return CreateBody(_fbb, name ? _fbb.CreateString(name) : 0, positions ? _fbb.CreateVector<const Point *>(*positions) : 0, momenta ? _fbb.CreateVector<const Point *>(*momenta) : 0, parent ? _fbb.CreateString(parent) : 0);
}

inline flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb, const BodyT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct BodiesT : public flatbuffers::NativeTable {
  typedef Bodies TableType;
  std::vector<std::unique_ptr<BodyT>> bodies;
  BodiesT() {}
};

struct Bodies FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BodiesT NativeTableType;
  enum {
    VT_BODIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Body>> *bodies() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Body>> *>(VT_BODIES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODIES) &&
           verifier.Verify(bodies()) &&
           verifier.VerifyVectorOfTables(bodies()) &&
           verifier.EndTable();
  }
  BodiesT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Bodies> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BodiesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bodies(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Body>>> bodies) { fbb_.AddOffset(Bodies::VT_BODIES, bodies); }
  BodiesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BodiesBuilder &operator=(const BodiesBuilder &);
  flatbuffers::Offset<Bodies> Finish() {
    auto o = flatbuffers::Offset<Bodies>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Bodies> CreateBodies(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Body>>> bodies = 0) {
  BodiesBuilder builder_(_fbb);
  builder_.add_bodies(bodies);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bodies> CreateBodiesDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Body>> *bodies = nullptr) {
  return CreateBodies(_fbb, bodies ? _fbb.CreateVector<flatbuffers::Offset<Body>>(*bodies) : 0);
}

inline flatbuffers::Offset<Bodies> CreateBodies(flatbuffers::FlatBufferBuilder &_fbb, const BodiesT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline BodyT *Body::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new BodyT();
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = positions(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->positions.push_back(*_e->Get(_i)); } } };
  { auto _e = momenta(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->momenta.push_back(*_e->Get(_i)); } } };
  { auto _e = parent(); if (_e) _o->parent = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<Body> Body::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBody(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb, const BodyT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateBody(_fbb,
    _o->name.size() ? _fbb.CreateString(_o->name) : 0,
    _o->positions.size() ? _fbb.CreateVectorOfStructs(_o->positions) : 0,
    _o->momenta.size() ? _fbb.CreateVectorOfStructs(_o->momenta) : 0,
    _o->parent.size() ? _fbb.CreateString(_o->parent) : 0);
}

inline BodiesT *Bodies::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new BodiesT();
  { auto _e = bodies(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bodies.push_back(std::unique_ptr<BodyT>(_e->Get(_i)->UnPack(resolver))); } } };
  return _o;
}

inline flatbuffers::Offset<Bodies> Bodies::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BodiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBodies(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Bodies> CreateBodies(flatbuffers::FlatBufferBuilder &_fbb, const BodiesT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateBodies(_fbb,
    _o->bodies.size() ? _fbb.CreateVector<flatbuffers::Offset<Body>>(_o->bodies.size(), [&](size_t i) { return CreateBody(_fbb, _o->bodies[i].get(), rehasher); }) : 0);
}

inline const BodyData::Bodies *GetBodies(const void *buf) {
  return flatbuffers::GetRoot<BodyData::Bodies>(buf);
}

inline bool VerifyBodiesBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BodyData::Bodies>(nullptr);
}

inline void FinishBodiesBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<BodyData::Bodies> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<BodiesT> UnPackBodies(const void *buf, const flatbuffers::resolver_function_t *resolver = nullptr) {
  return std::unique_ptr<BodiesT>(GetBodies(buf)->UnPack(resolver));
}

}  // namespace BodyData

#endif  // FLATBUFFERS_GENERATED_BODYDATA_BODYDATA_H_
